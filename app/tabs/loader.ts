// Centralized tab loader + metadata helper for the app
// Exports:
// - tabComponents: Record<compKey, React.LazyExoticComponent>
// - initialTabs: Array<{ compKey, name, value, label, order }>
// - applyTabMeta(initialTabs): Promise<updatedTabs>

import { lazy } from "react";
// manifest is generated by the Vite plugin. It's a hidden dotfile to indicate
// it's generated and should not be edited by hand: `.tabs.manifest.json`.
import manifest from "../.tabs.manifest.json";

// replicate the same glob discovery used in App.tsx (for lazy components)
const tabModules = import.meta.glob("./*Tab.tsx", { eager: false });

export const tabComponents = Object.keys(tabModules).reduce(
  (acc, path) => {
    const tabName = path.match(/\.\/([A-Za-z0-9_]+)Tab\.tsx$/)?.[1];
    if (tabName) {
      acc[`${tabName}Tab`] = lazy(() =>
        tabModules[path]().then((m: any) => ({ default: m[`${tabName}Tab`] }))
      );
    }
    return acc;
  },
  {} as Record<string, React.LazyExoticComponent<any>>
);

// initialTabs are provided by the build-time manifest. This is synchronous and
// avoids importing any tab modules at runtime.
export const initialTabs = (
  manifest as Array<{
    compKey: string;
    name: string;
    value: string;
    label: string;
    order: number;
    section: "catalyst" | "projects";
  }>
).slice();

// applyTabMeta is kept for API compatibility but is a fast pass-through since
// manifest already contains ordering/labels. Kept async to preserve original shape.
export async function applyTabMeta() {
  // Ensure we only return entries that correspond to discovered components
  const discoveredKeys = new Set(Object.keys(tabComponents));
  const filtered = initialTabs.filter(t => discoveredKeys.has(t.compKey));
  // Append any discovered components missing from manifest deterministically
  for (const compKey of Object.keys(tabComponents)) {
    if (!filtered.some(f => f.compKey === compKey)) {
      const name = compKey.replace(/Tab$/, "");
      const parts = name.split(/(?=[A-Z])/).filter(Boolean);
      filtered.push({
        compKey,
        name,
        value: parts.join("").toLowerCase(),
        label: parts.join(" "),
        order: filtered.length,
        section: "catalyst" as const,
      });
    }
  }
  return filtered.sort((a, b) => a.order - b.order || a.name.localeCompare(b.name));
}
